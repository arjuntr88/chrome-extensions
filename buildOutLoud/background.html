<!DOCTYPE html>
<!--
 * Copyright (c) 2010 The Chromium Authors. All rights reserved.  Use of this
 * source code is governed by a BSD-style license that can be found in the
 * LICENSE file.
-->
<html>
  <head>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.4/jquery.min.js" type="text/javascript"></script>
    <script>
	var request1;
var xhreq;
var regex1 = /Finished: SUCCESS/;
var cons = /console/;
var buildFin;
var url;
var buildStarted;
var job;
var rootUrl;
var activJobs = [];
var activJobCount = 0;
// Called when a message is passed.  We assume that the content script
// wants to show the page action.
function onRequest(request, sender, sendResponse) {
	// Show the page action for the tab that the sender (content script)
	// was on.
	
	//alert(sender.tab.url);
	chrome.pageAction.show(sender.tab.id);
	chrome.pageAction.setIcon({
			path : "DA.png",
			tabId : sender.tab.id
		});
	
	if (cons.test(sender.tab.url)) {
		request1 = null
			job = null;
		//console.log("sender.tab.url "+ sender.tab.url);
		url = sender.tab.url;
		buildStarted = 0;
		buildFin = 0;
		testBuild();
	}
	rootUrl=sender.tab.url; //rootUrl variable to store url of the tab

	testRoot();	//check whether it is infact root hudson page
	
	sendResponse({});
}

function getUrl(Url) {
	
	var pos = Url.lastIndexOf("console");
	
	if (pos == -1)
		return "";
	else
			return Url.slice(0, pos);
	
}

function testBuild() {
	//console.log("URL: " +url);
	if (request1 == null) {
		//console.log("testbuild req=false|null");
		
		doRequest();
		
		//sleep(5000);
	}
	if (request1 == "success") {
		//console.log("req==true");
		//console.log("testbuild req=true");
		
		var notification = webkitNotifications.createNotification('DA.png', 'success', 'Build Successfull, Job :' + job);
		notification.show();
	}
	if (request1 == "failure") {
		var notification = webkitNotifications.createNotification('DA.png', 'failure', 'Build Failed, Job :' + job);
		notification.show();
	}
	if (request1 == "aborted") {
		var notification = webkitNotifications.createNotification('DA.png', 'aborted', 'Build Aborted, Job :' + job);
		notification.show();
	}
	
	if (request1 == "building") {
		if (buildStarted < 1) {
			//console.log("testbuild req=building");
			var notification = webkitNotifications.createNotification('DA.png', 'Building', 'Build Started, Job :' + job);
			notification.show();
			buildStarted++;
		}
		doRequest();
	}
	
}

function doRequest() {
	var tabUrl = getUrl(url);
	//console.log("tab: "+tabUrl);
	
	var auth = null;
	if (xhreq) {
		xhreq.abort();
	}
	xhreq = new XMLHttpRequest();
	
	try {
		xhreq.onreadystatechange = checkResponse;
		//xhreq.onerror = handleError;
		xhreq.open('GET', tabUrl + 'api/json', true);
		if (typeof auth == 'string') {
			xhreq.setRequestHeader('Authorization', 'Basic ' + auth);
		}
		
		xhreq.send();
	} catch (e) {}
	
	//request1=true;
}

function checkResponse() {
	if (xhreq.readyState != 4)
		return;
	if (xhreq.status == 200 && xhreq.responseText) {
		var response = JSON.parse(xhreq.responseText);
		//console.log("JSON.parse done");
		//console.log("building :"+response.building);
		//console.log("result :"+response.result);
		if (!response.building && response.result == "SUCCESS") {
			
			//console.log("build success");
			request1 = "success";
			//return true;
			//buildFin++;
		} else if (!response.building && response.result == "FAILURE") {
			//console.log("build fail");
			request1 = "failure";
		} else if (response.building) {
			//console.log("building");
			request1 = "building";
		}
		else if (!response.building && response.result == "ABORTED") {
			request1 = "aborted";
		}
	} else {}
	console.log("chkresponse");
	job = response.fullDisplayName;
	setTimeout("testBuild()", 1000);
	return;
	
}
var rootxhr;
function testRoot() {
//console.log("in testRoot");
var auth=null;
if(rootxhr) {
rootxhr.abort();
}
rootxhr = new XMLHttpRequest();
try {
		rootxhr.onreadystatechange = rootResponse;
		rootxhr.onerror = handleError;
		rootxhr.open('GET', rootUrl + 'api/json', true);
		if (typeof auth == 'string') {
			rootxhr.setRequestHeader('Authorization', 'Basic ' + auth);
		}
		//console.log("test");
		rootxhr.send();
		//console.log("rootxhr sent");
	} catch (e) {
	console.log("error");
	}

}

function rootResponse() {
//console.log("in rootResponse");
if(rootxhr.readyState != 4)
return;
//console.log(rootxhr.status);
//console.log(rootxhr.responseText);
if(rootxhr.status == 200 && rootxhr.responseText) {
var response = JSON.parse(rootxhr.responseText);
if (response.jobs==null)
;
//console.log("not root page");
else {
	activJobs = [];			// re initialize on every reload
	activJobCount = 0;
for(x in response.jobs) {
//console.log(response.jobs[x].name);
checkForBuilds(response.jobs[x]);
}


}
console.log(activJobCount+": active jobs");
if (activJobCount>0)
setTimeout("testRoot()",1000);
}

 
//setTimeout("rootResponse()",100);
}

function handleError() {
console.log("xmlHTTPReq error");
}


function checkForBuilds(job) {
var active=/anime/;
//console.log("checking for build :" + job.name);
if (active.test(job.color)) {
var abc = checkStartStop(job,true);
console.log(abc);
if (abc=="notStarted")
{
activJobCount++;
console.log(job.name + " added to list");
}
//console.log(job.name +" is active");
}
else{
if (checkStartStop(job,false)=="stop")
activJobCount--;
//console.log(job.name +" is inactive");
}
//console.log(activJobCount);
}

function checkStartStop(job,building) { 
var rstr;
if (building) {

console.log(job.name + " is building");

if(activJobs.length>0) {
for (x in activJobs) {
//console.log(x);
if (job.name==activJobs[x])
{
console.log(job.name +" in list");
rstr = "Started";
}
else {
console.log(job.name +" now added");
activJobs.push(job.name);
rstr = "notStarted";
}
}
}
else if (activJobs.length == 0)
{
console.log(job.name +" now added");
activJobs.push(job.name);
rstr = "notStarted";
}
}
else if (!building) {
console.log(job.name+ "not building");
for (x in activJobs) {
//console.log(activJobs[x]);
if (job.name==activJobs[x]) {
activJobs.splice(x,1);
rstr = "stop";
}
}
}
/*for (x in activJobs)
console.log(x);
*/
console.log("returs string: "+rstr);
return rstr;
}
// Listen for the content script to send a message to the background page.
chrome.extension.onRequest.addListener(onRequest);
     </script>
  </head>
</html>
